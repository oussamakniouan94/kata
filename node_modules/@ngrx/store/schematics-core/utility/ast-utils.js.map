{"version":3,"file":"ast-utils.js","sourceRoot":"","sources":["../../../../../modules/store/schematics-core/utility/ast-utils.ts"],"names":[],"mappings":"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","sourcesContent":["/* istanbul ignore file */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as ts from 'typescript';\nimport {\n  Change,\n  InsertChange,\n  NoopChange,\n  createReplaceChange,\n  ReplaceChange,\n  RemoveChange,\n  createRemoveChange,\n} from './change';\nimport { Path } from '@angular-devkit/core';\n\n/**\n * Find all nodes from the AST in the subtree of node of SyntaxKind kind.\n * @param node\n * @param kind\n * @param max The maximum number of items to return.\n * @return all nodes of kind, or [] if none is found\n */\nexport function findNodes(\n  node: ts.Node,\n  kind: ts.SyntaxKind,\n  max = Infinity\n): ts.Node[] {\n  if (!node || max == 0) {\n    return [];\n  }\n\n  const arr: ts.Node[] = [];\n  if (node.kind === kind) {\n    arr.push(node);\n    max--;\n  }\n  if (max > 0) {\n    for (const child of node.getChildren()) {\n      findNodes(child, kind, max).forEach((node) => {\n        if (max > 0) {\n          arr.push(node);\n        }\n        max--;\n      });\n\n      if (max <= 0) {\n        break;\n      }\n    }\n  }\n\n  return arr;\n}\n\n/**\n * Get all the nodes from a source.\n * @param sourceFile The source file object.\n * @returns {Observable<ts.Node>} An observable of all the nodes in the source.\n */\nexport function getSourceNodes(sourceFile: ts.SourceFile): ts.Node[] {\n  const nodes: ts.Node[] = [sourceFile];\n  const result = [];\n\n  while (nodes.length > 0) {\n    const node = nodes.shift();\n\n    if (node) {\n      result.push(node);\n      if (node.getChildCount(sourceFile) >= 0) {\n        nodes.unshift(...node.getChildren());\n      }\n    }\n  }\n\n  return result;\n}\n\n/**\n * Helper for sorting nodes.\n * @return function to sort nodes in increasing order of position in sourceFile\n */\nfunction nodesByPosition(first: ts.Node, second: ts.Node): number {\n  return first.pos - second.pos;\n}\n\n/**\n * Insert `toInsert` after the last occurence of `ts.SyntaxKind[nodes[i].kind]`\n * or after the last of occurence of `syntaxKind` if the last occurence is a sub child\n * of ts.SyntaxKind[nodes[i].kind] and save the changes in file.\n *\n * @param nodes insert after the last occurence of nodes\n * @param toInsert string to insert\n * @param file file to insert changes into\n * @param fallbackPos position to insert if toInsert happens to be the first occurence\n * @param syntaxKind the ts.SyntaxKind of the subchildren to insert after\n * @return Change instance\n * @throw Error if toInsert is first occurence but fall back is not set\n */\nexport function insertAfterLastOccurrence(\n  nodes: ts.Node[],\n  toInsert: string,\n  file: string,\n  fallbackPos: number,\n  syntaxKind?: ts.SyntaxKind\n): Change {\n  let lastItem = nodes.sort(nodesByPosition).pop();\n  if (!lastItem) {\n    throw new Error();\n  }\n  if (syntaxKind) {\n    lastItem = findNodes(lastItem, syntaxKind).sort(nodesByPosition).pop();\n  }\n  if (!lastItem && fallbackPos == undefined) {\n    throw new Error(\n      `tried to insert ${toInsert} as first occurence with no fallback position`\n    );\n  }\n  const lastItemPosition: number = lastItem ? lastItem.end : fallbackPos;\n\n  return new InsertChange(file, lastItemPosition, toInsert);\n}\n\nexport function getContentOfKeyLiteral(\n  _source: ts.SourceFile,\n  node: ts.Node\n): string | null {\n  if (node.kind == ts.SyntaxKind.Identifier) {\n    return (node as ts.Identifier).text;\n  } else if (node.kind == ts.SyntaxKind.StringLiteral) {\n    return (node as ts.StringLiteral).text;\n  } else {\n    return null;\n  }\n}\n\nfunction _angularImportsFromNode(\n  node: ts.ImportDeclaration,\n  _sourceFile: ts.SourceFile\n): { [name: string]: string } {\n  const ms = node.moduleSpecifier;\n  let modulePath: string;\n  switch (ms.kind) {\n    case ts.SyntaxKind.StringLiteral:\n      modulePath = (ms as ts.StringLiteral).text;\n      break;\n    default:\n      return {};\n  }\n\n  if (!modulePath.startsWith('@angular/')) {\n    return {};\n  }\n\n  if (node.importClause) {\n    if (node.importClause.name) {\n      // This is of the form `import Name from 'path'`. Ignore.\n      return {};\n    } else if (node.importClause.namedBindings) {\n      const nb = node.importClause.namedBindings;\n      if (nb.kind == ts.SyntaxKind.NamespaceImport) {\n        // This is of the form `import * as name from 'path'`. Return `name.`.\n        return {\n          [(nb as ts.NamespaceImport).name.text + '.']: modulePath,\n        };\n      } else {\n        // This is of the form `import {a,b,c} from 'path'`\n        const namedImports = nb as ts.NamedImports;\n\n        return namedImports.elements\n          .map((is: ts.ImportSpecifier) =>\n            is.propertyName ? is.propertyName.text : is.name.text\n          )\n          .reduce((acc: { [name: string]: string }, curr: string) => {\n            acc[curr] = modulePath;\n\n            return acc;\n          }, {});\n      }\n    }\n\n    return {};\n  } else {\n    // This is of the form `import 'path';`. Nothing to do.\n    return {};\n  }\n}\n\nexport function getDecoratorMetadata(\n  source: ts.SourceFile,\n  identifier: string,\n  module: string\n): ts.Node[] {\n  const angularImports: { [name: string]: string } = findNodes(\n    source,\n    ts.SyntaxKind.ImportDeclaration\n  )\n    .map((node) =>\n      _angularImportsFromNode(node as ts.ImportDeclaration, source)\n    )\n    .reduce(\n      (\n        acc: { [name: string]: string },\n        current: { [name: string]: string }\n      ) => {\n        for (const key of Object.keys(current)) {\n          acc[key] = current[key];\n        }\n\n        return acc;\n      },\n      {}\n    );\n\n  return getSourceNodes(source)\n    .filter((node) => {\n      return (\n        node.kind == ts.SyntaxKind.Decorator &&\n        (node as ts.Decorator).expression.kind == ts.SyntaxKind.CallExpression\n      );\n    })\n    .map((node) => (node as ts.Decorator).expression as ts.CallExpression)\n    .filter((expr) => {\n      if (expr.expression.kind == ts.SyntaxKind.Identifier) {\n        const id = expr.expression as ts.Identifier;\n\n        return (\n          id.getFullText(source) == identifier &&\n          angularImports[id.getFullText(source)] === module\n        );\n      } else if (\n        expr.expression.kind == ts.SyntaxKind.PropertyAccessExpression\n      ) {\n        // This covers foo.NgModule when importing * as foo.\n        const paExpr = expr.expression as ts.PropertyAccessExpression;\n        // If the left expression is not an identifier, just give up at that point.\n        if (paExpr.expression.kind !== ts.SyntaxKind.Identifier) {\n          return false;\n        }\n\n        const id = paExpr.name.text;\n        const moduleId = (paExpr.expression as ts.Identifier).getText(source);\n\n        return id === identifier && angularImports[moduleId + '.'] === module;\n      }\n\n      return false;\n    })\n    .filter(\n      (expr) =>\n        expr.arguments[0] &&\n        expr.arguments[0].kind == ts.SyntaxKind.ObjectLiteralExpression\n    )\n    .map((expr) => expr.arguments[0] as ts.ObjectLiteralExpression);\n}\n\nfunction _addSymbolToNgModuleMetadata(\n  source: ts.SourceFile,\n  ngModulePath: string,\n  metadataField: string,\n  symbolName: string,\n  importPath: string\n): Change[] {\n  const nodes = getDecoratorMetadata(source, 'NgModule', '@angular/core');\n  let node: any = nodes[0]; // eslint-disable-line @typescript-eslint/no-explicit-any\n\n  // Find the decorator declaration.\n  if (!node) {\n    return [];\n  }\n\n  // Get all the children property assignment of object literals.\n  const matchingProperties: ts.ObjectLiteralElement[] = (\n    node as ts.ObjectLiteralExpression\n  ).properties\n    .filter((prop) => prop.kind == ts.SyntaxKind.PropertyAssignment)\n    // Filter out every fields that's not \"metadataField\". Also handles string literals\n    // (but not expressions).\n    .filter((prop: any) => {\n      const name = prop.name;\n      switch (name.kind) {\n        case ts.SyntaxKind.Identifier:\n          return (name as ts.Identifier).getText(source) == metadataField;\n        case ts.SyntaxKind.StringLiteral:\n          return (name as ts.StringLiteral).text == metadataField;\n      }\n\n      return false;\n    });\n\n  // Get the last node of the array literal.\n  if (!matchingProperties) {\n    return [];\n  }\n  if (matchingProperties.length == 0) {\n    // We haven't found the field in the metadata declaration. Insert a new field.\n    const expr = node as ts.ObjectLiteralExpression;\n    let position: number;\n    let toInsert: string;\n    if (expr.properties.length == 0) {\n      position = expr.getEnd() - 1;\n      toInsert = `  ${metadataField}: [${symbolName}]\\n`;\n    } else {\n      node = expr.properties[expr.properties.length - 1];\n      position = node.getEnd();\n      // Get the indentation of the last element, if any.\n      const text = node.getFullText(source);\n      const matches = text.match(/^\\r?\\n\\s*/);\n      if (matches.length > 0) {\n        toInsert = `,${matches[0]}${metadataField}: [${symbolName}]`;\n      } else {\n        toInsert = `, ${metadataField}: [${symbolName}]`;\n      }\n    }\n    const newMetadataProperty = new InsertChange(\n      ngModulePath,\n      position,\n      toInsert\n    );\n    const newMetadataImport = insertImport(\n      source,\n      ngModulePath,\n      symbolName.replace(/\\..*$/, ''),\n      importPath\n    );\n\n    return [newMetadataProperty, newMetadataImport];\n  }\n\n  const assignment = matchingProperties[0] as ts.PropertyAssignment;\n\n  // If it's not an array, nothing we can do really.\n  if (assignment.initializer.kind !== ts.SyntaxKind.ArrayLiteralExpression) {\n    return [];\n  }\n\n  const arrLiteral = assignment.initializer as ts.ArrayLiteralExpression;\n  if (arrLiteral.elements.length == 0) {\n    // Forward the property.\n    node = arrLiteral;\n  } else {\n    node = arrLiteral.elements;\n  }\n\n  if (!node) {\n    console.log(\n      'No app module found. Please add your new class to your component.'\n    );\n\n    return [];\n  }\n\n  if (Array.isArray(node)) {\n    const nodeArray = node as {} as Array<ts.Node>;\n    const symbolsArray = nodeArray.map((node) => node.getText());\n    if (symbolsArray.includes(symbolName)) {\n      return [];\n    }\n\n    node = node[node.length - 1];\n\n    const effectsModule = nodeArray.find(\n      (node) =>\n        (node.getText().includes('EffectsModule.forRoot') &&\n          symbolName.includes('EffectsModule.forRoot')) ||\n        (node.getText().includes('EffectsModule.forFeature') &&\n          symbolName.includes('EffectsModule.forFeature'))\n    );\n\n    if (effectsModule && symbolName.includes('EffectsModule')) {\n      const effectsArgs = (effectsModule as any).arguments.shift();\n\n      if (\n        effectsArgs &&\n        effectsArgs.kind === ts.SyntaxKind.ArrayLiteralExpression\n      ) {\n        const effectsElements = (effectsArgs as ts.ArrayLiteralExpression)\n          .elements;\n        const [, effectsSymbol] = (<any>symbolName).match(/\\[(.*)\\]/);\n\n        let epos;\n        if (effectsElements.length === 0) {\n          epos = effectsArgs.getStart() + 1;\n          return [new InsertChange(ngModulePath, epos, effectsSymbol)];\n        } else {\n          const lastEffect = effectsElements[\n            effectsElements.length - 1\n          ] as ts.Expression;\n          epos = lastEffect.getEnd();\n          // Get the indentation of the last element, if any.\n          const text: any = lastEffect.getFullText(source);\n\n          let effectInsert: string;\n          if (text.match('^\\r?\\r?\\n')) {\n            effectInsert = `,${text.match(/^\\r?\\n\\s+/)[0]}${effectsSymbol}`;\n          } else {\n            effectInsert = `, ${effectsSymbol}`;\n          }\n\n          return [new InsertChange(ngModulePath, epos, effectInsert)];\n        }\n      } else {\n        return [];\n      }\n    }\n  }\n\n  let toInsert: string;\n  let position = node.getEnd();\n  if (node.kind == ts.SyntaxKind.ObjectLiteralExpression) {\n    // We haven't found the field in the metadata declaration. Insert a new\n    // field.\n    const expr = node as ts.ObjectLiteralExpression;\n    if (expr.properties.length == 0) {\n      position = expr.getEnd() - 1;\n      toInsert = `  ${metadataField}: [${symbolName}]\\n`;\n    } else {\n      node = expr.properties[expr.properties.length - 1];\n      position = node.getEnd();\n      // Get the indentation of the last element, if any.\n      const text = node.getFullText(source);\n      if (text.match('^\\r?\\r?\\n')) {\n        toInsert = `,${\n          text.match(/^\\r?\\n\\s+/)[0]\n        }${metadataField}: [${symbolName}]`;\n      } else {\n        toInsert = `, ${metadataField}: [${symbolName}]`;\n      }\n    }\n  } else if (node.kind == ts.SyntaxKind.ArrayLiteralExpression) {\n    // We found the field but it's empty. Insert it just before the `]`.\n    position--;\n    toInsert = `${symbolName}`;\n  } else {\n    // Get the indentation of the last element, if any.\n    const text = node.getFullText(source);\n    if (text.match(/^\\r?\\n/)) {\n      toInsert = `,${text.match(/^\\r?\\n(\\r?)\\s+/)[0]}${symbolName}`;\n    } else {\n      toInsert = `, ${symbolName}`;\n    }\n  }\n  const insert = new InsertChange(ngModulePath, position, toInsert);\n  const importInsert: Change = insertImport(\n    source,\n    ngModulePath,\n    symbolName.replace(/\\..*$/, ''),\n    importPath\n  );\n\n  return [insert, importInsert];\n}\n\nfunction _addSymbolToComponentMetadata(\n  source: ts.SourceFile,\n  componentPath: string,\n  metadataField: string,\n  symbolName: string,\n  importPath: string\n): Change[] {\n  const nodes = getDecoratorMetadata(source, 'Component', '@angular/core');\n  let node: any = nodes[0]; // eslint-disable-line @typescript-eslint/no-explicit-any\n\n  // Find the decorator declaration.\n  if (!node) {\n    return [];\n  }\n\n  // Get all the children property assignment of object literals.\n  const matchingProperties: ts.ObjectLiteralElement[] = (\n    node as ts.ObjectLiteralExpression\n  ).properties\n    .filter((prop) => prop.kind == ts.SyntaxKind.PropertyAssignment)\n    // Filter out every fields that's not \"metadataField\". Also handles string literals\n    // (but not expressions).\n    .filter((prop: any) => {\n      const name = prop.name;\n      switch (name.kind) {\n        case ts.SyntaxKind.Identifier:\n          return (name as ts.Identifier).getText(source) == metadataField;\n        case ts.SyntaxKind.StringLiteral:\n          return (name as ts.StringLiteral).text == metadataField;\n      }\n\n      return false;\n    });\n\n  // Get the last node of the array literal.\n  if (!matchingProperties) {\n    return [];\n  }\n  if (matchingProperties.length == 0) {\n    // We haven't found the field in the metadata declaration. Insert a new field.\n    const expr = node as ts.ObjectLiteralExpression;\n    let position: number;\n    let toInsert: string;\n    if (expr.properties.length == 0) {\n      position = expr.getEnd() - 1;\n      toInsert = `  ${metadataField}: [${symbolName}]\\n`;\n    } else {\n      node = expr.properties[expr.properties.length - 1];\n      position = node.getEnd();\n      // Get the indentation of the last element, if any.\n      const text = node.getFullText(source);\n      const matches = text.match(/^\\r?\\n\\s*/);\n      if (matches.length > 0) {\n        toInsert = `,${matches[0]}${metadataField}: [${symbolName}]`;\n      } else {\n        toInsert = `, ${metadataField}: [${symbolName}]`;\n      }\n    }\n    const newMetadataProperty = new InsertChange(\n      componentPath,\n      position,\n      toInsert\n    );\n    const newMetadataImport = insertImport(\n      source,\n      componentPath,\n      symbolName.replace(/\\..*$/, ''),\n      importPath\n    );\n\n    return [newMetadataProperty, newMetadataImport];\n  }\n\n  const assignment = matchingProperties[0] as ts.PropertyAssignment;\n\n  // If it's not an array, nothing we can do really.\n  if (assignment.initializer.kind !== ts.SyntaxKind.ArrayLiteralExpression) {\n    return [];\n  }\n\n  const arrLiteral = assignment.initializer as ts.ArrayLiteralExpression;\n  if (arrLiteral.elements.length == 0) {\n    // Forward the property.\n    node = arrLiteral;\n  } else {\n    node = arrLiteral.elements;\n  }\n\n  if (!node) {\n    console.log(\n      'No component found. Please add your new class to your component.'\n    );\n\n    return [];\n  }\n\n  if (Array.isArray(node)) {\n    const nodeArray = node as {} as Array<ts.Node>;\n    const symbolsArray = nodeArray.map((node) => node.getText());\n    if (symbolsArray.includes(symbolName)) {\n      return [];\n    }\n\n    node = node[node.length - 1];\n  }\n\n  let toInsert: string;\n  let position = node.getEnd();\n  if (node.kind == ts.SyntaxKind.ObjectLiteralExpression) {\n    // We haven't found the field in the metadata declaration. Insert a new\n    // field.\n    const expr = node as ts.ObjectLiteralExpression;\n    if (expr.properties.length == 0) {\n      position = expr.getEnd() - 1;\n      toInsert = `  ${metadataField}: [${symbolName}]\\n`;\n    } else {\n      node = expr.properties[expr.properties.length - 1];\n      position = node.getEnd();\n      // Get the indentation of the last element, if any.\n      const text = node.getFullText(source);\n      if (text.match('^\\r?\\r?\\n')) {\n        toInsert = `,${\n          text.match(/^\\r?\\n\\s+/)[0]\n        }${metadataField}: [${symbolName}]`;\n      } else {\n        toInsert = `, ${metadataField}: [${symbolName}]`;\n      }\n    }\n  } else if (node.kind == ts.SyntaxKind.ArrayLiteralExpression) {\n    // We found the field but it's empty. Insert it just before the `]`.\n    position--;\n    toInsert = `${symbolName}`;\n  } else {\n    // Get the indentation of the last element, if any.\n    const text = node.getFullText(source);\n    if (text.match(/^\\r?\\n/)) {\n      toInsert = `,${text.match(/^\\r?\\n(\\r?)\\s+/)[0]}${symbolName}`;\n    } else {\n      toInsert = `, ${symbolName}`;\n    }\n  }\n  const insert = new InsertChange(componentPath, position, toInsert);\n  const importInsert: Change = insertImport(\n    source,\n    componentPath,\n    symbolName.replace(/\\..*$/, ''),\n    importPath\n  );\n\n  return [insert, importInsert];\n}\n\n/**\n * Custom function to insert a declaration (component, pipe, directive)\n * into NgModule declarations. It also imports the component.\n */\nexport function addDeclarationToModule(\n  source: ts.SourceFile,\n  modulePath: string,\n  classifiedName: string,\n  importPath: string\n): Change[] {\n  return _addSymbolToNgModuleMetadata(\n    source,\n    modulePath,\n    'declarations',\n    classifiedName,\n    importPath\n  );\n}\n\n/**\n * Custom function to insert a declaration (component, pipe, directive)\n * into NgModule declarations. It also imports the component.\n */\nexport function addImportToModule(\n  source: ts.SourceFile,\n  modulePath: string,\n  classifiedName: string,\n  importPath: string\n): Change[] {\n  return _addSymbolToNgModuleMetadata(\n    source,\n    modulePath,\n    'imports',\n    classifiedName,\n    importPath\n  );\n}\n\n/**\n * Custom function to insert a provider into NgModule. It also imports it.\n */\nexport function addProviderToModule(\n  source: ts.SourceFile,\n  modulePath: string,\n  classifiedName: string,\n  importPath: string\n): Change[] {\n  return _addSymbolToNgModuleMetadata(\n    source,\n    modulePath,\n    'providers',\n    classifiedName,\n    importPath\n  );\n}\n\n/**\n * Custom function to insert a provider into Component. It also imports it.\n */\nexport function addProviderToComponent(\n  source: ts.SourceFile,\n  componentPath: string,\n  classifiedName: string,\n  importPath: string\n): Change[] {\n  return _addSymbolToComponentMetadata(\n    source,\n    componentPath,\n    'providers',\n    classifiedName,\n    importPath\n  );\n}\n\n/**\n * Custom function to insert an export into NgModule. It also imports it.\n */\nexport function addExportToModule(\n  source: ts.SourceFile,\n  modulePath: string,\n  classifiedName: string,\n  importPath: string\n): Change[] {\n  return _addSymbolToNgModuleMetadata(\n    source,\n    modulePath,\n    'exports',\n    classifiedName,\n    importPath\n  );\n}\n\n/**\n * Custom function to insert an export into NgModule. It also imports it.\n */\nexport function addBootstrapToModule(\n  source: ts.SourceFile,\n  modulePath: string,\n  classifiedName: string,\n  importPath: string\n): Change[] {\n  return _addSymbolToNgModuleMetadata(\n    source,\n    modulePath,\n    'bootstrap',\n    classifiedName,\n    importPath\n  );\n}\n\n/**\n * Add Import `import { symbolName } from fileName` if the import doesn't exit\n * already. Assumes fileToEdit can be resolved and accessed.\n * @param fileToEdit (file we want to add import to)\n * @param symbolName (item to import)\n * @param fileName (path to the file)\n * @param isDefault (if true, import follows style for importing default exports)\n * @return Change\n */\n\nexport function insertImport(\n  source: ts.SourceFile,\n  fileToEdit: string,\n  symbolName: string,\n  fileName: string,\n  isDefault = false\n): Change {\n  const rootNode = source;\n  const allImports = findNodes(rootNode, ts.SyntaxKind.ImportDeclaration);\n\n  // get nodes that map to import statements from the file fileName\n  const relevantImports = allImports.filter((node) => {\n    // StringLiteral of the ImportDeclaration is the import file (fileName in this case).\n    const importFiles = node\n      .getChildren()\n      .filter((child) => child.kind === ts.SyntaxKind.StringLiteral)\n      .map((n) => (n as ts.StringLiteral).text);\n\n    return importFiles.filter((file) => file === fileName).length === 1;\n  });\n\n  if (relevantImports.length > 0) {\n    let importsAsterisk = false;\n    // imports from import file\n    const imports: ts.Node[] = [];\n    relevantImports.forEach((n) => {\n      Array.prototype.push.apply(\n        imports,\n        findNodes(n, ts.SyntaxKind.Identifier)\n      );\n      if (findNodes(n, ts.SyntaxKind.AsteriskToken).length > 0) {\n        importsAsterisk = true;\n      }\n    });\n\n    // if imports * from fileName, don't add symbolName\n    if (importsAsterisk) {\n      return new NoopChange();\n    }\n\n    const importTextNodes = imports.filter(\n      (n) => (n as ts.Identifier).text === symbolName\n    );\n\n    // insert import if it's not there\n    if (importTextNodes.length === 0) {\n      const fallbackPos =\n        findNodes(\n          relevantImports[0],\n          ts.SyntaxKind.CloseBraceToken\n        )[0].getStart() ||\n        findNodes(relevantImports[0], ts.SyntaxKind.FromKeyword)[0].getStart();\n\n      return insertAfterLastOccurrence(\n        imports,\n        `, ${symbolName}`,\n        fileToEdit,\n        fallbackPos\n      );\n    }\n\n    return new NoopChange();\n  }\n\n  // no such import declaration exists\n  const useStrict = findNodes(rootNode, ts.SyntaxKind.StringLiteral).filter(\n    (n) => n.getText() === 'use strict'\n  );\n  let fallbackPos = 0;\n  if (useStrict.length > 0) {\n    fallbackPos = useStrict[0].end;\n  }\n  const open = isDefault ? '' : '{ ';\n  const close = isDefault ? '' : ' }';\n  // if there are no imports or 'use strict' statement, insert import at beginning of file\n  const insertAtBeginning = allImports.length === 0 && useStrict.length === 0;\n  const separator = insertAtBeginning ? '' : ';\\n';\n  const toInsert =\n    `${separator}import ${open}${symbolName}${close}` +\n    ` from '${fileName}'${insertAtBeginning ? ';\\n' : ''}`;\n\n  return insertAfterLastOccurrence(\n    allImports,\n    toInsert,\n    fileToEdit,\n    fallbackPos,\n    ts.SyntaxKind.StringLiteral\n  );\n}\n\nexport function replaceImport(\n  sourceFile: ts.SourceFile,\n  path: Path,\n  importFrom: string,\n  importAsIs: string,\n  importToBe: string\n): (ReplaceChange | RemoveChange)[] {\n  const imports = sourceFile.statements\n    .filter(ts.isImportDeclaration)\n    .filter(\n      ({ moduleSpecifier }) =>\n        moduleSpecifier.getText(sourceFile) === `'${importFrom}'` ||\n        moduleSpecifier.getText(sourceFile) === `\"${importFrom}\"`\n    );\n\n  if (imports.length === 0) {\n    return [];\n  }\n\n  const importText = (specifier: ts.ImportSpecifier) => {\n    if (specifier.name.text) {\n      return specifier.name.text;\n    }\n\n    // if import is renamed\n    if (specifier.propertyName && specifier.propertyName.text) {\n      return specifier.propertyName.text;\n    }\n\n    return '';\n  };\n\n  const changes = imports.map((p) => {\n    const namedImports = p?.importClause?.namedBindings as ts.NamedImports;\n    if (!namedImports) {\n      return [];\n    }\n\n    const importSpecifiers = namedImports.elements;\n    const isAlreadyImported = importSpecifiers\n      .map(importText)\n      .includes(importToBe);\n\n    const importChanges = importSpecifiers.map((specifier, index) => {\n      const text = importText(specifier);\n\n      // import is not the one we're looking for, can be skipped\n      if (text !== importAsIs) {\n        return undefined;\n      }\n\n      // identifier has not been imported, simply replace the old text with the new text\n      if (!isAlreadyImported) {\n        return createReplaceChange(\n          sourceFile,\n          specifier,\n          importAsIs,\n          importToBe\n        );\n      }\n\n      const nextIdentifier = importSpecifiers[index + 1];\n      // identifer is not the last, also clean up the comma\n      if (nextIdentifier) {\n        return createRemoveChange(\n          sourceFile,\n          specifier,\n          specifier.getStart(sourceFile),\n          nextIdentifier.getStart(sourceFile)\n        );\n      }\n\n      // there are no imports following, just remove it\n      return createRemoveChange(\n        sourceFile,\n        specifier,\n        specifier.getStart(sourceFile),\n        specifier.getEnd()\n      );\n    });\n\n    return importChanges.filter(Boolean) as (ReplaceChange | RemoveChange)[];\n  });\n\n  return changes.reduce((imports, curr) => imports.concat(curr), []);\n}\n\nexport function containsProperty(\n  objectLiteral: ts.ObjectLiteralExpression,\n  propertyName: string\n) {\n  return (\n    objectLiteral &&\n    objectLiteral.properties.some(\n      (prop) =>\n        ts.isPropertyAssignment(prop) &&\n        ts.isIdentifier(prop.name) &&\n        prop.name.text === propertyName\n    )\n  );\n}\n"]}