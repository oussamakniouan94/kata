import * as i0 from '@angular/core';
import { ValueEqualityFn, OnDestroy, Injector, Signal, EffectRef, InjectionToken, ModuleWithProviders, EnvironmentProviders } from '@angular/core';
import { BehaviorSubject, Observable, Subject, Observer, Operator } from 'rxjs';

interface Action<Type extends string = string> {
    type: Type;
}
type ActionType<A> = A extends ActionCreator<infer T, infer C> ? ReturnType<C> & {
    type: T;
} : never;
type TypeId<T> = () => T;
type InitialState<T> = Partial<T> | TypeId<Partial<T>> | void;
/**
 * A function that takes an `Action` and a `State`, and returns a `State`.
 * See `createReducer`.
 */
interface ActionReducer<T, V extends Action = Action> {
    (state: T | undefined, action: V): T;
}
type ActionReducerMap<T, V extends Action = Action> = {
    [p in keyof T]: ActionReducer<T[p], V>;
};
interface ActionReducerFactory<T, V extends Action = Action> {
    (reducerMap: ActionReducerMap<T, V>, initialState?: InitialState<T>): ActionReducer<T, V>;
}
type MetaReducer<T = any, V extends Action = Action> = (reducer: ActionReducer<T, V>) => ActionReducer<T, V>;
interface StoreFeature<T, V extends Action = Action> {
    key: string;
    reducers: ActionReducerMap<T, V> | ActionReducer<T, V>;
    reducerFactory: ActionReducerFactory<T, V>;
    initialState?: InitialState<T>;
    metaReducers?: MetaReducer<T, V>[];
}
type Selector<T, V> = (state: T) => V;
/**
 * @deprecated Selectors with props are deprecated, for more info see {@link https://github.com/ngrx/platform/issues/2980 Github Issue}
 */
type SelectorWithProps<State, Props, Result> = (state: State, props: Props) => Result;
declare const arraysAreNotAllowedMsg = "action creator cannot return an array";
type ArraysAreNotAllowed = typeof arraysAreNotAllowedMsg;
declare const typePropertyIsNotAllowedMsg = "action creator cannot return an object with a property named `type`";
type TypePropertyIsNotAllowed = typeof typePropertyIsNotAllowedMsg;
declare const emptyObjectsAreNotAllowedMsg = "action creator cannot return an empty object";
type EmptyObjectsAreNotAllowed = typeof emptyObjectsAreNotAllowedMsg;
declare const arraysAreNotAllowedInProps = "action creator props cannot be an array";
type ArraysAreNotAllowedInProps = typeof arraysAreNotAllowedInProps;
declare const typePropertyIsNotAllowedInProps = "action creator props cannot have a property named `type`";
type TypePropertyIsNotAllowedInProps = typeof typePropertyIsNotAllowedInProps;
declare const emptyObjectsAreNotAllowedInProps = "action creator props cannot be an empty object";
type EmptyObjectsAreNotAllowedInProps = typeof emptyObjectsAreNotAllowedInProps;
declare const primitivesAreNotAllowedInProps = "action creator props cannot be a primitive value";
type PrimitivesAreNotAllowedInProps = typeof primitivesAreNotAllowedInProps;
type CreatorsNotAllowedCheck<T> = T extends ActionCreator ? 'Action creator is not allowed to be dispatched. Did you forget to call it?' : unknown;
/**
 * A function that returns an object in the shape of the `Action` interface.  Configured using `createAction`.
 */
type Creator<P extends any[] = any[], R extends object = object> = FunctionWithParametersType<P, R>;
type Primitive = string | number | bigint | boolean | symbol | null | undefined;
type NotAllowedCheck<T extends object> = T extends any[] ? ArraysAreNotAllowed : T extends {
    type: any;
} ? TypePropertyIsNotAllowed : keyof T extends never ? EmptyObjectsAreNotAllowed : unknown;
type NotAllowedInPropsCheck<T> = T extends object ? T extends any[] ? ArraysAreNotAllowedInProps : T extends {
    type: any;
} ? TypePropertyIsNotAllowedInProps : keyof T extends never ? EmptyObjectsAreNotAllowedInProps : unknown : T extends Primitive ? PrimitivesAreNotAllowedInProps : never;
/**
 * See `Creator`.
 */
type ActionCreator<T extends string = string, C extends Creator = Creator> = C & Action<T>;
interface ActionCreatorProps<T> {
    _as: 'props';
    _p: T;
}
type FunctionWithParametersType<P extends unknown[], R = void> = (...args: P) => R;
interface RuntimeChecks {
    /**
     * Verifies if the state is serializable
     */
    strictStateSerializability: boolean;
    /**
     * Verifies if the actions are serializable. Please note, you may not need to set it to `true` unless you are storing/replaying actions using external resources, for example `localStorage`.
     */
    strictActionSerializability: boolean;
    /**
     * Verifies that the state isn't mutated
     */
    strictStateImmutability: boolean;
    /**
     * Verifies that actions aren't mutated
     */
    strictActionImmutability: boolean;
    /**
     * Verifies that actions are dispatched within NgZone
     */
    strictActionWithinNgZone: boolean;
    /**
     * Verifies that action types are not registered more than once
     */
    strictActionTypeUniqueness?: boolean;
}
interface SelectSignalOptions<T> {
    /**
     *  A comparison function which defines equality for select results.
     */
    equal?: ValueEqualityFn<T>;
}
type Prettify<T> = {
    [K in keyof T]: T[K];
} & {};

/**
 * @description
 * Creates a configured `Creator` function that, when called, returns an object in the shape of the
 * `Action` interface with no additional metadata.
 *
 * @param type Describes the action that will be dispatched
 *
 * @usageNotes
 *
 * Declaring an action creator:
 *
 * ```ts
 * export const increment = createAction('[Counter] Increment');
 * ```
 *
 * Dispatching an action:
 *
 * ```ts
 * store.dispatch(increment());
 * ```
 *
 * Referencing the action in a reducer:
 *
 * ```ts
 * on(CounterActions.increment, (state) => ({ ...state, count: state.count + 1 }))
 * ```
 *
 * Referencing the action in an effect:
 * ```ts
 * effectName$ = createEffect(
 *   () => this.actions$.pipe(
 *     ofType(CounterActions.increment),
 *     // ...
 *   )
 * );
 * ```
 */
declare function createAction<T extends string>(type: T): ActionCreator<T, () => Action<T>>;
/**
 * @description
 * Creates a configured `Creator` function that, when called, returns an object in the shape of the
 * `Action` interface with metadata provided by the `props` or `emptyProps` functions.
 *
 * @param type Describes the action that will be dispatched
 *
 * @usageNotes
 *
 * Declaring an action creator:
 *
 * ```ts
 * export const loginSuccess = createAction(
 *   '[Auth/API] Login Success',
 *   props<{ user: User }>()
 * );
 * ```
 *
 * Dispatching an action:
 *
 * ```ts
 * store.dispatch(loginSuccess({ user: newUser }));
 * ```
 *
 * Referencing the action in a reducer:
 *
 * ```ts
 * on(AuthApiActions.loginSuccess, (state, { user }) => ({ ...state, user }))
 * ```
 *
 * Referencing the action in an effect:
 * ```ts
 * effectName$ = createEffect(
 *   () => this.actions$.pipe(
 *     ofType(AuthApiActions.loginSuccess),
 *     // ...
 *   )
 * );
 * ```
 */
declare function createAction<T extends string, P extends object>(type: T, config: ActionCreatorProps<P> & NotAllowedCheck<P>): ActionCreator<T, (props: P & NotAllowedCheck<P>) => P & Action<T>>;
declare function createAction<T extends string, P extends any[], R extends object>(type: T, creator: Creator<P, R & NotAllowedCheck<R>>): FunctionWithParametersType<P, R & Action<T>> & Action<T>;
declare function props<P extends SafeProps, SafeProps = NotAllowedInPropsCheck<P>>(): ActionCreatorProps<P>;
declare function union<C extends {
    [key: string]: ActionCreator<string, Creator>;
}>(creators: C): ReturnType<C[keyof C]>;

type Join<Str extends string, Separator extends string = ' '> = Str extends `${infer First}${Separator}${infer Rest}` ? Join<`${First}${Rest}`, Separator> : Str;
type CapitalizeWords<Str extends string> = Str extends `${infer First} ${infer Rest}` ? `${Capitalize<First>} ${CapitalizeWords<Rest>}` : Capitalize<Str>;
type StringLiteralCheck<Str extends string, Name extends string> = string extends Str ? `${Name} must be a string literal type` : unknown;
type UniqueEventNameCheck<EventNames extends string, EventName extends string> = ActionName<EventName> extends ActionName<Exclude<EventNames, EventName>> ? `${ActionName<EventName>} action is already defined` : unknown;
type NotAllowedEventPropsCheck<PropsCreator extends ActionCreatorProps<unknown> | Creator> = PropsCreator extends ActionCreatorProps<infer Props> ? Props extends void ? unknown : NotAllowedCheck<Props & object> : PropsCreator extends Creator<any, infer Result> ? NotAllowedCheck<Result> : unknown;
type EventCreator<PropsCreator extends ActionCreatorProps<unknown> | Creator, Type extends string> = PropsCreator extends ActionCreatorProps<infer Props> ? void extends Props ? ActionCreator<Type, () => Action<Type>> : ActionCreator<Type, (props: Props & NotAllowedCheck<Props & object>) => Props & Action<Type>> : PropsCreator extends Creator<infer Props, infer Result> ? FunctionWithParametersType<Props, Result & NotAllowedCheck<Result> & Action<Type>> & Action<Type> : never;
type ActionName<EventName extends string> = Uncapitalize<Join<CapitalizeWords<EventName>>>;
interface ActionGroupConfig<Source extends string, Events extends Record<string, ActionCreatorProps<unknown> | Creator>> {
    source: Source & StringLiteralCheck<Source, 'source'>;
    events: Events & {
        [EventName in keyof Events]: StringLiteralCheck<EventName & string, 'event name'> & UniqueEventNameCheck<keyof Events & string, EventName & string> & NotAllowedEventPropsCheck<Events[EventName]>;
    };
}
type ActionGroup<Source extends string, Events extends Record<string, ActionCreatorProps<unknown> | Creator>> = {
    [EventName in keyof Events as ActionName<EventName & string>]: EventCreator<Events[EventName], `[${Source}] ${EventName & string}`>;
};
/**
 * @description
 * A function that creates a group of action creators with the same source.
 *
 * @param config An object that contains a source and dictionary of events.
 * An event is a key-value pair of an event name and event props.
 * @returns A dictionary of action creators.
 * The name of each action creator is created by camel casing the event name.
 * The type of each action is created using the "[Source] Event Name" pattern.
 *
 * @usageNotes
 *
 * ```ts
 * const authApiActions = createActionGroup({
 *   source: 'Auth API',
 *   events: {
 *     // defining events with payload using the `props` function
 *     'Login Success': props<{ userId: number; token: string }>(),
 *     'Login Failure': props<{ error: string }>(),
 *
 *     // defining an event without payload using the `emptyProps` function
 *     'Logout Success': emptyProps(),
 *
 *     // defining an event with payload using the props factory
 *     'Logout Failure': (error: Error) => ({ error }),
 *   },
 * });
 *
 * // action type: "[Auth API] Login Success"
 * authApiActions.loginSuccess({ userId: 10, token: 'ngrx' });
 *
 * // action type: "[Auth API] Login Failure"
 * authApiActions.loginFailure({ error: 'Login Failure!' });
 *
 * // action type: "[Auth API] Logout Success"
 * authApiActions.logoutSuccess();
 *
 * // action type: "[Auth API] Logout Failure";
 * authApiActions.logoutFailure(new Error('Logout Failure!'));
 * ```
 */
declare function createActionGroup<Source extends string, Events extends Record<string, ActionCreatorProps<unknown> | Creator>>(config: ActionGroupConfig<Source, Events>): ActionGroup<Source, Events>;
declare function emptyProps(): ActionCreatorProps<void>;

declare const INIT: "@ngrx/store/init";
declare class ActionsSubject extends BehaviorSubject<Action> implements OnDestroy {
    constructor();
    next(action: Action): void;
    complete(): void;
    ngOnDestroy(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<ActionsSubject, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<ActionsSubject>;
}

declare abstract class ReducerObservable extends Observable<ActionReducer<any, any>> {
}
declare abstract class ReducerManagerDispatcher extends ActionsSubject {
}
declare const UPDATE: "@ngrx/store/update-reducers";
declare class ReducerManager extends BehaviorSubject<ActionReducer<any, any>> implements OnDestroy {
    private dispatcher;
    private initialState;
    private reducers;
    private reducerFactory;
    get currentReducers(): ActionReducerMap<any, any>;
    constructor(dispatcher: ReducerManagerDispatcher, initialState: any, reducers: ActionReducerMap<any, any>, reducerFactory: ActionReducerFactory<any, any>);
    addFeature(feature: StoreFeature<any, any>): void;
    addFeatures(features: StoreFeature<any, any>[]): void;
    removeFeature(feature: StoreFeature<any, any>): void;
    removeFeatures(features: StoreFeature<any, any>[]): void;
    addReducer(key: string, reducer: ActionReducer<any, any>): void;
    addReducers(reducers: {
        [key: string]: ActionReducer<any, any>;
    }): void;
    removeReducer(featureKey: string): void;
    removeReducers(featureKeys: string[]): void;
    private updateReducers;
    ngOnDestroy(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<ReducerManager, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<ReducerManager>;
}

declare class ScannedActionsSubject extends Subject<Action> implements OnDestroy {
    ngOnDestroy(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<ScannedActionsSubject, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<ScannedActionsSubject>;
}

declare abstract class StateObservable extends Observable<any> {
}
declare class State$1<T> extends BehaviorSubject<any> implements OnDestroy {
    static readonly INIT: "@ngrx/store/init";
    private stateSubscription;
    constructor(actions$: ActionsSubject, reducer$: ReducerObservable, scannedActions: ScannedActionsSubject, initialState: any);
    ngOnDestroy(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<State$1<any>, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<State$1<any>>;
}
type StateActionPair<T, V extends Action = Action> = {
    state: T | undefined;
    action?: V;
};
declare function reduceState<T, V extends Action = Action>(stateActionPair: StateActionPair<T, V> | undefined, [action, reducer]: [V, ActionReducer<T, V>]): StateActionPair<T, V>;

declare class Store<T = object> extends Observable<T> implements Observer<Action> {
    private actionsObserver;
    private reducerManager;
    private injector?;
    constructor(state$: StateObservable, actionsObserver: ActionsSubject, reducerManager: ReducerManager, injector?: Injector | undefined);
    select<K>(mapFn: (state: T) => K): Observable<K>;
    /**
     * @deprecated Selectors with props are deprecated, for more info see {@link https://github.com/ngrx/platform/issues/2980 Github Issue}
     */
    select<K, Props = any>(mapFn: (state: T, props: Props) => K, props: Props): Observable<K>;
    /**
     * @deprecated Selectors with props are deprecated, for more info see {@link https://github.com/ngrx/platform/issues/2980 Github Issue}
     */
    select<a extends keyof T>(key: a): Observable<T[a]>;
    /**
     * @deprecated Selectors with props are deprecated, for more info see {@link https://github.com/ngrx/platform/issues/2980 Github Issue}
     */
    select<a extends keyof T, b extends keyof T[a]>(key1: a, key2: b): Observable<T[a][b]>;
    /**
     * @deprecated Selectors with props are deprecated, for more info see {@link https://github.com/ngrx/platform/issues/2980 Github Issue}
     */
    select<a extends keyof T, b extends keyof T[a], c extends keyof T[a][b]>(key1: a, key2: b, key3: c): Observable<T[a][b][c]>;
    /**
     * @deprecated Selectors with props are deprecated, for more info see {@link https://github.com/ngrx/platform/issues/2980 Github Issue}
     */
    select<a extends keyof T, b extends keyof T[a], c extends keyof T[a][b], d extends keyof T[a][b][c]>(key1: a, key2: b, key3: c, key4: d): Observable<T[a][b][c][d]>;
    /**
     * @deprecated Selectors with props are deprecated, for more info see {@link https://github.com/ngrx/platform/issues/2980 Github Issue}
     */
    select<a extends keyof T, b extends keyof T[a], c extends keyof T[a][b], d extends keyof T[a][b][c], e extends keyof T[a][b][c][d]>(key1: a, key2: b, key3: c, key4: d, key5: e): Observable<T[a][b][c][d][e]>;
    /**
     * @deprecated Selectors with props are deprecated, for more info see {@link https://github.com/ngrx/platform/issues/2980 Github Issue}
     */
    select<a extends keyof T, b extends keyof T[a], c extends keyof T[a][b], d extends keyof T[a][b][c], e extends keyof T[a][b][c][d], f extends keyof T[a][b][c][d][e]>(key1: a, key2: b, key3: c, key4: d, key5: e, key6: f): Observable<T[a][b][c][d][e][f]>;
    /**
     * @deprecated Selectors with props are deprecated, for more info see {@link https://github.com/ngrx/platform/issues/2980 Github Issue}
     */
    select<a extends keyof T, b extends keyof T[a], c extends keyof T[a][b], d extends keyof T[a][b][c], e extends keyof T[a][b][c][d], f extends keyof T[a][b][c][d][e], K = any>(key1: a, key2: b, key3: c, key4: d, key5: e, key6: f, ...paths: string[]): Observable<K>;
    /**
     * Returns a signal of the provided selector.
     *
     * @param selector selector function
     * @param options select signal options
     * @returns Signal of the state selected by the provided selector
     * @usageNotes
     *
     * ```ts
     * const count = this.store.selectSignal(state => state.count);
     * ```
     *
     * Or with a selector created by @ngrx/store!createSelector:function
     *
     * ```ts
     * const selectCount = createSelector(
     *  (state: State) => state.count,
     * );
     *
     * const count = this.store.selectSignal(selectCount);
     * ```
     */
    selectSignal<K>(selector: (state: T) => K, options?: SelectSignalOptions<K>): Signal<K>;
    lift<R>(operator: Operator<T, R>): Store<R>;
    dispatch<V extends Action>(action: V & CreatorsNotAllowedCheck<V>): void;
    dispatch<V extends () => Action>(dispatchFn: V & CreatorsNotAllowedCheck<V>, config?: {
        injector: Injector;
    }): EffectRef;
    next(action: Action): void;
    error(err: any): void;
    complete(): void;
    addReducer<State, Actions extends Action = Action>(key: string, reducer: ActionReducer<State, Actions>): void;
    removeReducer<Key extends Extract<keyof T, string>>(key: Key): void;
    private processDispatchFn;
    static ɵfac: i0.ɵɵFactoryDeclaration<Store<any>, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<Store<any>>;
}
declare function select<T, K>(mapFn: (state: T) => K): (source$: Observable<T>) => Observable<K>;
/**
 * @deprecated Selectors with props are deprecated, for more info see {@link https://github.com/ngrx/platform/issues/2980 Github Issue}
 */
declare function select<T, Props, K>(mapFn: (state: T, props: Props) => K, props: Props): (source$: Observable<T>) => Observable<K>;
declare function select<T, a extends keyof T>(key: a): (source$: Observable<T>) => Observable<T[a]>;
declare function select<T, a extends keyof T, b extends keyof T[a]>(key1: a, key2: b): (source$: Observable<T>) => Observable<T[a][b]>;
declare function select<T, a extends keyof T, b extends keyof T[a], c extends keyof T[a][b]>(key1: a, key2: b, key3: c): (source$: Observable<T>) => Observable<T[a][b][c]>;
declare function select<T, a extends keyof T, b extends keyof T[a], c extends keyof T[a][b], d extends keyof T[a][b][c]>(key1: a, key2: b, key3: c, key4: d): (source$: Observable<T>) => Observable<T[a][b][c][d]>;
declare function select<T, a extends keyof T, b extends keyof T[a], c extends keyof T[a][b], d extends keyof T[a][b][c], e extends keyof T[a][b][c][d]>(key1: a, key2: b, key3: c, key4: d, key5: e): (source$: Observable<T>) => Observable<T[a][b][c][d][e]>;
declare function select<T, a extends keyof T, b extends keyof T[a], c extends keyof T[a][b], d extends keyof T[a][b][c], e extends keyof T[a][b][c][d], f extends keyof T[a][b][c][d][e]>(key1: a, key2: b, key3: c, key4: d, key5: e, key6: f): (source$: Observable<T>) => Observable<T[a][b][c][d][e][f]>;
declare function select<T, a extends keyof T, b extends keyof T[a], c extends keyof T[a][b], d extends keyof T[a][b][c], e extends keyof T[a][b][c][d], f extends keyof T[a][b][c][d][e], K = any>(key1: a, key2: b, key3: c, key4: d, key5: e, key6: f, ...paths: string[]): (source$: Observable<T>) => Observable<K>;

declare function combineReducers<T, V extends Action = Action>(reducers: ActionReducerMap<T, V>, initialState?: Partial<T>): ActionReducer<T, V>;
declare function compose<A>(): (i: A) => A;
declare function compose<A, B>(b: (i: A) => B): (i: A) => B;
declare function compose<A, B, C>(c: (i: B) => C, b: (i: A) => B): (i: A) => C;
declare function compose<A, B, C, D>(d: (i: C) => D, c: (i: B) => C, b: (i: A) => B): (i: A) => D;
declare function compose<A, B, C, D, E>(e: (i: D) => E, d: (i: C) => D, c: (i: B) => C, b: (i: A) => B): (i: A) => E;
declare function compose<A, B, C, D, E, F>(f: (i: E) => F, e: (i: D) => E, d: (i: C) => D, c: (i: B) => C, b: (i: A) => B): (i: A) => F;
declare function compose<A = any, F = any>(...functions: any[]): (i: A) => F;
declare function createReducerFactory<T, V extends Action = Action>(reducerFactory: ActionReducerFactory<T, V>, metaReducers?: MetaReducer<T, V>[]): ActionReducerFactory<T, V>;

type AnyFn = (...args: any[]) => any;
type MemoizedProjection = {
    memoized: AnyFn;
    reset: () => void;
    setResult: (result?: any) => void;
    clearResult: () => void;
};
type MemoizeFn = (t: AnyFn) => MemoizedProjection;
type ComparatorFn = (a: any, b: any) => boolean;
type DefaultProjectorFn<T> = (...args: any[]) => T;
interface MemoizedSelector<State, Result, ProjectorFn = DefaultProjectorFn<Result>> extends Selector<State, Result> {
    release(): void;
    projector: ProjectorFn;
    setResult: (result?: Result) => void;
    clearResult: () => void;
}
/**
 * @deprecated Selectors with props are deprecated, for more info see the {@link https://ngrx.io/guide/migration/v12#ngrxstore migration guide}
 */
interface MemoizedSelectorWithProps<State, Props, Result, ProjectorFn = DefaultProjectorFn<Result>> extends SelectorWithProps<State, Props, Result> {
    release(): void;
    projector: ProjectorFn;
    setResult: (result?: Result) => void;
    clearResult: () => void;
}
declare function isEqualCheck(a: any, b: any): boolean;
declare function resultMemoize(projectionFn: AnyFn, isResultEqual: ComparatorFn): MemoizedProjection;
declare function defaultMemoize(projectionFn: AnyFn, isArgumentsEqual?: typeof isEqualCheck, isResultEqual?: typeof isEqualCheck): MemoizedProjection;
declare function createSelector<State, S1, Result>(s1: Selector<State, S1>, projector: (s1: S1) => Result): MemoizedSelector<State, Result, typeof projector>;
declare function createSelector<State, S1, S2, Result>(s1: Selector<State, S1>, s2: Selector<State, S2>, projector: (s1: S1, s2: S2) => Result): MemoizedSelector<State, Result, typeof projector>;
declare function createSelector<State, S1, S2, S3, Result>(s1: Selector<State, S1>, s2: Selector<State, S2>, s3: Selector<State, S3>, projector: (s1: S1, s2: S2, s3: S3) => Result): MemoizedSelector<State, Result, typeof projector>;
declare function createSelector<State, S1, S2, S3, S4, Result>(s1: Selector<State, S1>, s2: Selector<State, S2>, s3: Selector<State, S3>, s4: Selector<State, S4>, projector: (s1: S1, s2: S2, s3: S3, s4: S4) => Result): MemoizedSelector<State, Result, typeof projector>;
declare function createSelector<State, S1, S2, S3, S4, S5, Result>(s1: Selector<State, S1>, s2: Selector<State, S2>, s3: Selector<State, S3>, s4: Selector<State, S4>, s5: Selector<State, S5>, projector: (s1: S1, s2: S2, s3: S3, s4: S4, s5: S5) => Result): MemoizedSelector<State, Result, typeof projector>;
declare function createSelector<State, S1, S2, S3, S4, S5, S6, Result>(s1: Selector<State, S1>, s2: Selector<State, S2>, s3: Selector<State, S3>, s4: Selector<State, S4>, s5: Selector<State, S5>, s6: Selector<State, S6>, projector: (s1: S1, s2: S2, s3: S3, s4: S4, s5: S5, s6: S6) => Result): MemoizedSelector<State, Result, typeof projector>;
declare function createSelector<State, S1, S2, S3, S4, S5, S6, S7, Result>(s1: Selector<State, S1>, s2: Selector<State, S2>, s3: Selector<State, S3>, s4: Selector<State, S4>, s5: Selector<State, S5>, s6: Selector<State, S6>, s7: Selector<State, S7>, projector: (s1: S1, s2: S2, s3: S3, s4: S4, s5: S5, s6: S6, s7: S7) => Result): MemoizedSelector<State, Result, typeof projector>;
declare function createSelector<State, S1, S2, S3, S4, S5, S6, S7, S8, Result>(s1: Selector<State, S1>, s2: Selector<State, S2>, s3: Selector<State, S3>, s4: Selector<State, S4>, s5: Selector<State, S5>, s6: Selector<State, S6>, s7: Selector<State, S7>, s8: Selector<State, S8>, projector: (s1: S1, s2: S2, s3: S3, s4: S4, s5: S5, s6: S6, s7: S7, s8: S8) => Result): MemoizedSelector<State, Result, typeof projector>;
declare function createSelector<Selectors extends Record<string, Selector<State, unknown>>, State = Selectors extends Record<string, Selector<infer S, unknown>> ? S : never, Result extends Record<string, unknown> = {
    [Key in keyof Selectors]: Selectors[Key] extends Selector<State, infer R> ? R : never;
}>(selectors: Selectors): MemoizedSelector<State, Result, never>;
declare function createSelector<State, Slices extends unknown[], Result>(...args: [...slices: Selector<State, unknown>[], projector: unknown] & [
    ...slices: {
        [i in keyof Slices]: Selector<State, Slices[i]>;
    },
    projector: (...s: Slices) => Result
]): MemoizedSelector<State, Result, (...s: Slices) => Result>;
/**
 * @deprecated Selectors with props are deprecated, for more info see {@link https://github.com/ngrx/platform/issues/2980 Github Issue}
 */
declare function createSelector<State, Props, S1, Result>(s1: SelectorWithProps<State, Props, S1>, projector: (s1: S1, props: Props) => Result): MemoizedSelectorWithProps<State, Props, Result, typeof projector>;
/**
 * @deprecated Selectors with props are deprecated, for more info see {@link https://github.com/ngrx/platform/issues/2980 Github Issue}
 */
declare function createSelector<State, Props, S1, S2, Result>(s1: SelectorWithProps<State, Props, S1>, s2: SelectorWithProps<State, Props, S2>, projector: (s1: S1, s2: S2, props: Props) => Result): MemoizedSelectorWithProps<State, Props, Result, typeof projector>;
/**
 * @deprecated Selectors with props are deprecated, for more info see {@link https://github.com/ngrx/platform/issues/2980 Github Issue}
 */
declare function createSelector<State, Props, S1, S2, S3, Result>(s1: SelectorWithProps<State, Props, S1>, s2: SelectorWithProps<State, Props, S2>, s3: SelectorWithProps<State, Props, S3>, projector: (s1: S1, s2: S2, s3: S3, props: Props) => Result): MemoizedSelectorWithProps<State, Props, Result, typeof projector>;
/**
 * @deprecated Selectors with props are deprecated, for more info see {@link https://github.com/ngrx/platform/issues/2980 Github Issue}
 */
declare function createSelector<State, Props, S1, S2, S3, S4, Result>(s1: SelectorWithProps<State, Props, S1>, s2: SelectorWithProps<State, Props, S2>, s3: SelectorWithProps<State, Props, S3>, s4: SelectorWithProps<State, Props, S4>, projector: (s1: S1, s2: S2, s3: S3, s4: S4, props: Props) => Result): MemoizedSelectorWithProps<State, Props, Result, typeof projector>;
/**
 * @deprecated Selectors with props are deprecated, for more info see {@link https://github.com/ngrx/platform/issues/2980 Github Issue}
 */
declare function createSelector<State, Props, S1, S2, S3, S4, S5, Result>(s1: SelectorWithProps<State, Props, S1>, s2: SelectorWithProps<State, Props, S2>, s3: SelectorWithProps<State, Props, S3>, s4: SelectorWithProps<State, Props, S4>, s5: SelectorWithProps<State, Props, S5>, projector: (s1: S1, s2: S2, s3: S3, s4: S4, s5: S5, props: Props) => Result): MemoizedSelectorWithProps<State, Props, Result, typeof projector>;
/**
 * @deprecated Selectors with props are deprecated, for more info see {@link https://github.com/ngrx/platform/issues/2980 Github Issue}
 */
declare function createSelector<State, Props, S1, S2, S3, S4, S5, S6, Result>(s1: SelectorWithProps<State, Props, S1>, s2: SelectorWithProps<State, Props, S2>, s3: SelectorWithProps<State, Props, S3>, s4: SelectorWithProps<State, Props, S4>, s5: SelectorWithProps<State, Props, S5>, s6: SelectorWithProps<State, Props, S6>, projector: (s1: S1, s2: S2, s3: S3, s4: S4, s5: S5, s6: S6, props: Props) => Result): MemoizedSelectorWithProps<State, Props, Result, typeof projector>;
/**
 * @deprecated Selectors with props are deprecated, for more info see {@link https://github.com/ngrx/platform/issues/2980 Github Issue}
 */
declare function createSelector<State, Props, S1, S2, S3, S4, S5, S6, S7, Result>(s1: SelectorWithProps<State, Props, S1>, s2: SelectorWithProps<State, Props, S2>, s3: SelectorWithProps<State, Props, S3>, s4: SelectorWithProps<State, Props, S4>, s5: SelectorWithProps<State, Props, S5>, s6: SelectorWithProps<State, Props, S6>, s7: SelectorWithProps<State, Props, S7>, projector: (s1: S1, s2: S2, s3: S3, s4: S4, s5: S5, s6: S6, s7: S7, props: Props) => Result): MemoizedSelectorWithProps<State, Props, Result, typeof projector>;
/**
 * @deprecated Selectors with props are deprecated, for more info see {@link https://github.com/ngrx/platform/issues/2980 Github Issue}
 */
declare function createSelector<State, Props, S1, S2, S3, S4, S5, S6, S7, S8, Result>(s1: SelectorWithProps<State, Props, S1>, s2: SelectorWithProps<State, Props, S2>, s3: SelectorWithProps<State, Props, S3>, s4: SelectorWithProps<State, Props, S4>, s5: SelectorWithProps<State, Props, S5>, s6: SelectorWithProps<State, Props, S6>, s7: SelectorWithProps<State, Props, S7>, s8: SelectorWithProps<State, Props, S8>, projector: (s1: S1, s2: S2, s3: S3, s4: S4, s5: S5, s6: S6, s7: S7, s8: S8, props: Props) => Result): MemoizedSelectorWithProps<State, Props, Result, typeof projector>;
declare function createSelector<State, Slices extends unknown[], Result>(selectors: Selector<State, unknown>[] & [
    ...{
        [i in keyof Slices]: Selector<State, Slices[i]>;
    }
], projector: (...s: Slices) => Result): MemoizedSelector<State, Result, (...s: Slices) => Result>;
/**
 * @deprecated Selectors with props are deprecated, for more info see {@link https://github.com/ngrx/platform/issues/2980 Github Issue}
 */
declare function createSelector<State, Props, S1, Result>(selectors: [SelectorWithProps<State, Props, S1>], projector: (s1: S1, props: Props) => Result): MemoizedSelectorWithProps<State, Props, Result, typeof projector>;
/**
 * @deprecated Selectors with props are deprecated, for more info see {@link https://github.com/ngrx/platform/issues/2980 Github Issue}
 */
declare function createSelector<State, Props, S1, S2, Result>(selectors: [
    SelectorWithProps<State, Props, S1>,
    SelectorWithProps<State, Props, S2>
], projector: (s1: S1, s2: S2, props: Props) => Result): MemoizedSelectorWithProps<State, Props, Result, typeof projector>;
/**
 * @deprecated Selectors with props are deprecated, for more info see {@link https://github.com/ngrx/platform/issues/2980 Github Issue}
 */
declare function createSelector<State, Props, S1, S2, S3, Result>(selectors: [
    SelectorWithProps<State, Props, S1>,
    SelectorWithProps<State, Props, S2>,
    SelectorWithProps<State, Props, S3>
], projector: (s1: S1, s2: S2, s3: S3, props: Props) => Result): MemoizedSelectorWithProps<State, Props, Result, typeof projector>;
/**
 * @deprecated Selectors with props are deprecated, for more info see {@link https://github.com/ngrx/platform/issues/2980 Github Issue}
 */
declare function createSelector<State, Props, S1, S2, S3, S4, Result>(selectors: [
    SelectorWithProps<State, Props, S1>,
    SelectorWithProps<State, Props, S2>,
    SelectorWithProps<State, Props, S3>,
    SelectorWithProps<State, Props, S4>
], projector: (s1: S1, s2: S2, s3: S3, s4: S4, props: Props) => Result): MemoizedSelectorWithProps<State, Props, Result, typeof projector>;
/**
 * @deprecated Selectors with props are deprecated, for more info see {@link https://github.com/ngrx/platform/issues/2980 Github Issue}
 */
declare function createSelector<State, Props, S1, S2, S3, S4, S5, Result>(selectors: [
    SelectorWithProps<State, Props, S1>,
    SelectorWithProps<State, Props, S2>,
    SelectorWithProps<State, Props, S3>,
    SelectorWithProps<State, Props, S4>,
    SelectorWithProps<State, Props, S5>
], projector: (s1: S1, s2: S2, s3: S3, s4: S4, s5: S5, props: Props) => Result): MemoizedSelectorWithProps<State, Props, Result, typeof projector>;
/**
 * @deprecated Selectors with props are deprecated, for more info see {@link https://github.com/ngrx/platform/issues/2980 Github Issue}
 */
declare function createSelector<State, Props, S1, S2, S3, S4, S5, S6, Result>(selectors: [
    SelectorWithProps<State, Props, S1>,
    SelectorWithProps<State, Props, S2>,
    SelectorWithProps<State, Props, S3>,
    SelectorWithProps<State, Props, S4>,
    SelectorWithProps<State, Props, S5>,
    SelectorWithProps<State, Props, S6>
], projector: (s1: S1, s2: S2, s3: S3, s4: S4, s5: S5, s6: S6, props: Props) => Result): MemoizedSelectorWithProps<State, Props, Result, typeof projector>;
/**
 * @deprecated Selectors with props are deprecated, for more info see {@link https://github.com/ngrx/platform/issues/2980 Github Issue}
 */
declare function createSelector<State, Props, S1, S2, S3, S4, S5, S6, S7, Result>(selectors: [
    SelectorWithProps<State, Props, S1>,
    SelectorWithProps<State, Props, S2>,
    SelectorWithProps<State, Props, S3>,
    SelectorWithProps<State, Props, S4>,
    SelectorWithProps<State, Props, S5>,
    SelectorWithProps<State, Props, S6>,
    SelectorWithProps<State, Props, S7>
], projector: (s1: S1, s2: S2, s3: S3, s4: S4, s5: S5, s6: S6, s7: S7, props: Props) => Result): MemoizedSelectorWithProps<State, Props, Result, typeof projector>;
/**
 * @deprecated Selectors with props are deprecated, for more info see {@link https://github.com/ngrx/platform/issues/2980 Github Issue}
 */
declare function createSelector<State, Props, S1, S2, S3, S4, S5, S6, S7, S8, Result>(selectors: [
    SelectorWithProps<State, Props, S1>,
    SelectorWithProps<State, Props, S2>,
    SelectorWithProps<State, Props, S3>,
    SelectorWithProps<State, Props, S4>,
    SelectorWithProps<State, Props, S5>,
    SelectorWithProps<State, Props, S6>,
    SelectorWithProps<State, Props, S7>,
    SelectorWithProps<State, Props, S8>
], projector: (s1: S1, s2: S2, s3: S3, s4: S4, s5: S5, s6: S6, s7: S7, s8: S8, props: Props) => Result): MemoizedSelectorWithProps<State, Props, Result, typeof projector>;
declare function defaultStateFn(state: any, selectors: Selector<any, any>[] | SelectorWithProps<any, any, any>[], props: any, memoizedProjector: MemoizedProjection): any;
type SelectorFactoryConfig<T = any, V = any> = {
    stateFn: (state: T, selectors: Selector<any, any>[], props: any, memoizedProjector: MemoizedProjection) => V;
};
declare function createSelectorFactory<T = any, V = any>(memoize: MemoizeFn): (...input: any[]) => MemoizedSelector<T, V>;
declare function createSelectorFactory<T = any, V = any>(memoize: MemoizeFn, options: SelectorFactoryConfig<T, V>): (...input: any[]) => MemoizedSelector<T, V>;
/**
 * @deprecated Selectors with props are deprecated, for more info see {@link https://github.com/ngrx/platform/issues/2980 Github Issue}
 */
declare function createSelectorFactory<T = any, Props = any, V = any>(memoize: MemoizeFn): (...input: any[]) => MemoizedSelectorWithProps<T, Props, V>;
/**
 * @deprecated Selectors with props are deprecated, for more info see {@link https://github.com/ngrx/platform/issues/2980 Github Issue}
 */
declare function createSelectorFactory<T = any, Props = any, V = any>(memoize: MemoizeFn, options: SelectorFactoryConfig<T, V>): (...input: any[]) => MemoizedSelectorWithProps<T, Props, V>;
declare function createFeatureSelector<T>(featureName: string): MemoizedSelector<object, T>;
/**
 * @deprecated  Feature selectors with a root state are deprecated, for more info see {@link https://github.com/ngrx/platform/issues/3179 Github Issue}
 */
declare function createFeatureSelector<T, V>(featureName: keyof T): MemoizedSelector<T, V>;

interface FeatureConfig<FeatureName extends string, FeatureState> {
    name: FeatureName;
    reducer: ActionReducer<FeatureState>;
}
type Feature<FeatureName extends string, FeatureState> = FeatureConfig<FeatureName, FeatureState> & BaseSelectors<FeatureName, FeatureState>;
type FeatureWithExtraSelectors<FeatureName extends string, FeatureState, ExtraSelectors extends SelectorsDictionary> = string extends keyof ExtraSelectors ? Feature<FeatureName, FeatureState> : Omit<Feature<FeatureName, FeatureState>, keyof ExtraSelectors> & ExtraSelectors;
type FeatureSelector<FeatureName extends string, FeatureState> = {
    [K in FeatureName as `select${Capitalize<K>}State`]: MemoizedSelector<Record<string, any>, FeatureState, (featureState: FeatureState) => FeatureState>;
};
type NestedSelectors<FeatureState> = FeatureState extends Primitive | unknown[] | Date ? {} : {
    [K in keyof FeatureState & string as `select${Capitalize<K>}`]: MemoizedSelector<Record<string, any>, FeatureState[K], (featureState: FeatureState) => FeatureState[K]>;
};
type BaseSelectors<FeatureName extends string, FeatureState> = FeatureSelector<FeatureName, FeatureState> & NestedSelectors<FeatureState>;
type SelectorsDictionary = Record<string, Selector<Record<string, any>, unknown> | ((...args: any[]) => Selector<Record<string, any>, unknown>)>;
type ExtraSelectorsFactory<FeatureName extends string, FeatureState, ExtraSelectors extends SelectorsDictionary> = (baseSelectors: BaseSelectors<FeatureName, FeatureState>) => ExtraSelectors;
type NotAllowedFeatureStateCheck<FeatureState> = FeatureState extends Required<FeatureState> ? unknown : 'optional properties are not allowed in the feature state';
/**
 * Creates a feature object with extra selectors.
 *
 * @param featureConfig An object that contains a feature name, a feature
 * reducer, and extra selectors factory.
 * @returns An object that contains a feature name, a feature reducer,
 * a feature selector, a selector for each feature state property, and
 * extra selectors.
 */
declare function createFeature<FeatureName extends string, FeatureState, ExtraSelectors extends SelectorsDictionary>(featureConfig: FeatureConfig<FeatureName, FeatureState> & {
    extraSelectors: ExtraSelectorsFactory<FeatureName, FeatureState, ExtraSelectors>;
} & NotAllowedFeatureStateCheck<FeatureState>): Prettify<FeatureWithExtraSelectors<FeatureName, FeatureState, ExtraSelectors>>;
/**
 * Creates a feature object.
 *
 * @param featureConfig An object that contains a feature name and a feature
 * reducer.
 * @returns An object that contains a feature name, a feature reducer,
 * a feature selector, and a selector for each feature state property.
 */
declare function createFeature<FeatureName extends string, FeatureState>(featureConfig: FeatureConfig<FeatureName, FeatureState> & NotAllowedFeatureStateCheck<FeatureState>): Prettify<Feature<FeatureName, FeatureState>>;

declare function setNgrxMockEnvironment(value: boolean): void;
declare function isNgrxMockEnvironment(): boolean;

declare const INITIAL_STATE: InjectionToken<unknown>;
declare const REDUCER_FACTORY: InjectionToken<unknown>;
declare const INITIAL_REDUCERS: InjectionToken<unknown>;
declare const STORE_FEATURES: InjectionToken<unknown>;
declare const FEATURE_REDUCERS: InjectionToken<unknown>;
/**
 * User-defined meta reducers from StoreModule.forRoot()
 */
declare const USER_PROVIDED_META_REDUCERS: InjectionToken<MetaReducer[]>;
/**
 * Meta reducers defined either internally by @ngrx/store or by library authors
 */
declare const META_REDUCERS: InjectionToken<MetaReducer[]>;
/**
 * Runtime checks defined by the user via an InjectionToken
 * Defaults to `_USER_RUNTIME_CHECKS`
 */
declare const USER_RUNTIME_CHECKS: InjectionToken<RuntimeChecks>;
/**
 * Runtime checks currently in use
 */
declare const ACTIVE_RUNTIME_CHECKS: InjectionToken<RuntimeChecks>;
/**
 * InjectionToken that registers the global Store.
 * Mainly used to provide a hook that can be injected
 * to ensure the root state is loaded before something
 * that depends on it.
 */
declare const ROOT_STORE_PROVIDER: InjectionToken<void>;
/**
 * InjectionToken that registers feature states.
 * Mainly used to provide a hook that can be injected
 * to ensure feature state is loaded before something
 * that depends on it.
 */
declare const FEATURE_STATE_PROVIDER: InjectionToken<void>;

interface StoreConfig<T, V extends Action = Action> {
    initialState?: InitialState<T>;
    reducerFactory?: ActionReducerFactory<T, V>;
    metaReducers?: MetaReducer<{
        [P in keyof T]: T[P];
    }, V>[];
}
interface RootStoreConfig<T, V extends Action = Action> extends StoreConfig<T, V> {
    runtimeChecks?: Partial<RuntimeChecks>;
}
/**
 * An object with the name and the reducer for the feature.
 */
interface FeatureSlice<T, V extends Action = Action> {
    name: string;
    reducer: ActionReducer<T, V>;
}

declare class StoreRootModule {
    constructor(actions$: ActionsSubject, reducer$: ReducerObservable, scannedActions$: ScannedActionsSubject, store: Store<any>, guard: any, actionCheck: any);
    static ɵfac: i0.ɵɵFactoryDeclaration<StoreRootModule, [null, null, null, null, { optional: true; }, { optional: true; }]>;
    static ɵmod: i0.ɵɵNgModuleDeclaration<StoreRootModule, never, never, never>;
    static ɵinj: i0.ɵɵInjectorDeclaration<StoreRootModule>;
}
declare class StoreFeatureModule implements OnDestroy {
    private features;
    private featureReducers;
    private reducerManager;
    constructor(features: StoreFeature<any, any>[], featureReducers: ActionReducerMap<any>[], reducerManager: ReducerManager, root: StoreRootModule, actionCheck: any);
    ngOnDestroy(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<StoreFeatureModule, [null, null, null, null, { optional: true; }]>;
    static ɵmod: i0.ɵɵNgModuleDeclaration<StoreFeatureModule, never, never, never>;
    static ɵinj: i0.ɵɵInjectorDeclaration<StoreFeatureModule>;
}
declare class StoreModule {
    static forRoot<T, V extends Action = Action>(reducers?: ActionReducerMap<T, V> | InjectionToken<ActionReducerMap<T, V>>, config?: RootStoreConfig<T, V>): ModuleWithProviders<StoreRootModule>;
    static forFeature<T, V extends Action = Action>(featureName: string, reducers: ActionReducerMap<T, V> | InjectionToken<ActionReducerMap<T, V>>, config?: StoreConfig<T, V> | InjectionToken<StoreConfig<T, V>>): ModuleWithProviders<StoreFeatureModule>;
    static forFeature<T, V extends Action = Action>(featureName: string, reducer: ActionReducer<T, V> | InjectionToken<ActionReducer<T, V>>, config?: StoreConfig<T, V> | InjectionToken<StoreConfig<T, V>>): ModuleWithProviders<StoreFeatureModule>;
    static forFeature<T, V extends Action = Action>(slice: FeatureSlice<T, V>): ModuleWithProviders<StoreFeatureModule>;
    static ɵfac: i0.ɵɵFactoryDeclaration<StoreModule, never>;
    static ɵmod: i0.ɵɵNgModuleDeclaration<StoreModule, never, never, never>;
    static ɵinj: i0.ɵɵInjectorDeclaration<StoreModule>;
}

declare function provideState<T, V extends Action = Action>(featureName: string, reducers: ActionReducerMap<T, V> | InjectionToken<ActionReducerMap<T, V>>, config?: StoreConfig<T, V> | InjectionToken<StoreConfig<T, V>>): EnvironmentProviders;
declare function provideState<T, V extends Action = Action>(featureName: string, reducer: ActionReducer<T, V> | InjectionToken<ActionReducer<T, V>>, config?: StoreConfig<T, V> | InjectionToken<StoreConfig<T, V>>): EnvironmentProviders;
declare function provideState<T, V extends Action = Action>(slice: FeatureSlice<T, V>): EnvironmentProviders;
/**
 * Provides the global Store providers and initializes
 * the Store.
 * These providers cannot be used at the component level.
 *
 * @usageNotes
 *
 * ### Providing the Global Store
 *
 * ```ts
 * bootstrapApplication(AppComponent, {
 *   providers: [provideStore()],
 * });
 * ```
 */
declare function provideStore<T, V extends Action = Action>(reducers?: ActionReducerMap<T, V> | InjectionToken<ActionReducerMap<T, V>>, config?: RootStoreConfig<T, V>): EnvironmentProviders;

type ExtractActionTypes<Creators extends readonly ActionCreator[]> = {
    [Key in keyof Creators]: Creators[Key] extends ActionCreator<infer T> ? T : never;
};
/**
 * Return type of the `on` fn.
 * Contains the action reducer coupled to one or more action types.
 */
interface ReducerTypes<State, Creators extends readonly ActionCreator[]> {
    reducer: OnReducer<State, Creators>;
    types: ExtractActionTypes<Creators>;
}
/**
 *  Specialized Reducer that is aware of the Action type it needs to handle
 */
interface OnReducer<State, Creators extends readonly ActionCreator[], InferredState = State, ResultState = unknown extends State ? InferredState : State> {
    (state: unknown extends State ? InferredState : State, action: ActionType<Creators[number]>): ResultState;
}
/**
 * @description
 * Associates actions with a given state change function.
 * A state change function must be provided as the last parameter.
 *
 * @param args `ActionCreator`'s followed by a state change function.
 *
 * @returns an association of action types with a state change function.
 *
 * @usageNotes
 * ```ts
 * on(AuthApiActions.loginSuccess, (state, { user }) => ({ ...state, user }))
 * ```
 */
declare function on<State, Creators extends readonly ActionCreator[], InferredState = State>(...args: [
    ...creators: Creators,
    reducer: OnReducer<State extends infer S ? S : never, Creators, InferredState>
]): ReducerTypes<unknown extends State ? InferredState : State, Creators>;
/**
 * @description
 * Creates a reducer function to handle state transitions.
 *
 * Reducer creators reduce the explicitness of reducer functions with switch statements.
 *
 * @param initialState Provides a state value if the current state is `undefined`, as it is initially.
 * @param ons Associations between actions and state changes.
 * @returns A reducer function.
 *
 * @usageNotes
 *
 * - Must be used with `ActionCreator`'s (returned by `createAction`). Cannot be used with class-based action creators.
 * - The returned `ActionReducer` does not require being wrapped with another function.
 *
 * **Declaring a reducer creator**
 *
 * ```ts
 * export const reducer = createReducer(
 *   initialState,
 *   on(
 *     featureActions.actionOne,
 *     featureActions.actionTwo,
 *     (state, { updatedValue }) => ({ ...state, prop: updatedValue })
 *   ),
 *   on(featureActions.actionThree, () => initialState);
 * );
 * ```
 */
declare function createReducer<S, A extends Action = Action, R extends ActionReducer<S, A> = ActionReducer<S, A>>(initialState: S, ...ons: ReducerTypes<S, readonly ActionCreator[]>[]): R;

export { ACTIVE_RUNTIME_CHECKS, ActionsSubject, FEATURE_REDUCERS, FEATURE_STATE_PROVIDER, INIT, INITIAL_REDUCERS, INITIAL_STATE, META_REDUCERS, REDUCER_FACTORY, ROOT_STORE_PROVIDER, ReducerManager, ReducerManagerDispatcher, ReducerObservable, STORE_FEATURES, ScannedActionsSubject, State$1 as State, StateObservable, Store, StoreFeatureModule, StoreModule, StoreRootModule, UPDATE, USER_PROVIDED_META_REDUCERS, USER_RUNTIME_CHECKS, combineReducers, compose, createAction, createActionGroup, createFeature, createFeatureSelector, createReducer, createReducerFactory, createSelector, createSelectorFactory, defaultMemoize, defaultStateFn, emptyProps, isNgrxMockEnvironment, on, props, provideState, provideStore, reduceState, resultMemoize, select, setNgrxMockEnvironment, union };
export type { Action, ActionCreator, ActionCreatorProps, ActionReducer, ActionReducerFactory, ActionReducerMap, ActionType, Creator, DefaultProjectorFn, FeatureConfig, FeatureSlice, FunctionWithParametersType, MemoizeFn, MemoizedProjection, MemoizedSelector, MemoizedSelectorWithProps, MetaReducer, NotAllowedCheck, ReducerTypes, RootStoreConfig, RuntimeChecks, Selector, SelectorWithProps, StoreConfig };
